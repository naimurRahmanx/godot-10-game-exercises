# Godot 2D â€“ 10 Game Learning Exercises ðŸŽ®

This repository is a structured learning journey through **Godot 4.x (2D)**, built by creating **10 small games**, followed by one final integration project.

The goal is not polish.

The goal is understanding:
- how Godot scenes work
- how signals work
- how systems communicate
- how game logic is structured
- how to think like a game developer

Each game introduces new concepts while reinforcing previous ones.

The final project combines everything into one complete, release-ready game.

---

## Why This Repository Exists

I am learning Godot by:

- Building small, complete games
- Avoiding tutorial hell
- Rebuilding systems multiple times
- Understanding *why* things work, not just *how*
- Prioritizing structure over shortcuts

This repository is both:
- A personal learning log
- A structured progression roadmap
- A reference for other beginners

---

## Engine & Scope

- Engine: **Godot 4.x**
- Focus: **2D only**
- Language: **GDScript**
- Platform: Desktop (PC)

---

# Games Overview

---

### Game 01 â€“ Dodge the Falling Blocks
**Concepts learned:**
- Scenes & instancing
- CharacterBody2D vs Area2D
- Player movement
- Timers
- Signals (built-in & custom)
- Collision layers & masks
- Game loop control
- Clamping movement using sprite size

---

### Game 02 â€“ Clicker Game
**Concepts learned:**
- Control nodes
- Buttons & Labels
- UI signals
- Score systems
- Updating UI dynamically
- Basic state handling

---

### Game 03 â€“ Top-Down Movement Arena
**Concepts learned:**
- 4/8 direction movement
- Normalized movement
- Static collisions
- Movement feel & control
- Input structure refinement

---

### Game 04 â€“ Simple Shooter
**Concepts learned:**
- Shooting projectiles
- Spawning bullets correctly in world space
- Groups
- Destroying nodes safely
- Collision filtering
- Object responsibility separation

---

### Game 05 â€“ Pong / Breakout Clone
**Concepts learned:**
- Ball physics
- Reflection logic
- Game state reset
- Score tracking
- Managing win/lose conditions

---

### Game 06 â€“ Endless Runner
**Concepts learned:**
- Continuous movement
- Procedural spawning
- Difficulty scaling
- Object cleanup
- Performance awareness

---

### Game 07 â€“ Mini Platformer
**Concepts learned:**
- Gravity & jumping
- Floor detection
- Platforms
- Camera following
- Movement tuning

---

### Game 08 â€“ Simple Enemy AI
**Concepts learned:**
- Distance checks
- Basic AI states
- Player chasing logic
- State-based behavior

---

### Game 09 â€“ Data-Driven Game
**Concepts learned:**
- Resources
- Separating data from logic
- Reusable enemies & items
- Cleaner system architecture

---

### Game 10 â€“ Small Complete Game
**Concepts learned:**
- Menus
- Pause system
- Restart logic
- Saving simple data
- Finishing and polishing a small game

---

# Final Project â€“ Complete Arena Survival Game ðŸŽ“

This is the integration project.

It combines everything learned in the previous 10 games into one cohesive, structured, release-ready 2D game.

This is not a prototype.
This is a complete small game.

**Concepts applied and reinforced:**

- Clean scene architecture
- Player movement refinement
- Shooting systems
- Multiple enemy types
- Basic enemy AI (chasing & variation)
- Wave-based spawning
- Difficulty scaling over time
- Health & damage system
- Score tracking
- Power-ups
- Data-driven enemy configuration
- UI integration (health, score, waves)
- Pause & restart systems
- Clean game state management
- Folder organization
- Removing magic numbers
- Debug discipline
- Finishing a project properly

The goal of this final game is not complexity.

The goal is control.

If this project feels stable, organized, and maintainable,
then the learning objective of this repository has been achieved.

---

# How to Use This Repository

Each folder is a **standalone Godot project**.

To run a game:

1. Open Godot
2. Import the project from the specific game folder
3. Run the main scene

Each game is intentionally simple.

Structure > Cleverness.

---

# Notes

- These games are intentionally minimal.
- Code clarity is preferred over optimization.
- Art is placeholder.
- Systems are built step by step.
- Finished > Perfect.

---

# License

MIT â€“ feel free to learn, copy, and modify.
